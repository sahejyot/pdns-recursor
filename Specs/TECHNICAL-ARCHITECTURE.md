# Technical Architecture Document
## PowerDNS Recursor - Cross-Platform (Windows Support)

**Document Version**: 1.0  
**Date**: October 27, 2025  
**Author**: Technical Architecture Team  
**Status**: Draft for Review

---

## 1. Architecture Overview

### 1.1 Design Principles

**1. Single Source Tree**
- One codebase for all platforms
- Conditional compilation for platform differences
- Minimize platform-specific code

**2. Platform Abstraction**
- Abstract platform-specific APIs
- Common interfaces for I/O, threading, etc.
- Platform implementations behind interfaces

**3. Zero Regression**
- No performance loss on Linux
- Existing functionality preserved
- New code isolated with #ifdef

**4. Maintainability**
- Clear separation of concerns
- Platform code in dedicated modules
- Well-documented platform differences

---

## 2. System Architecture

### 2.1 High-Level Architecture

```
┌──────────────────────────────────────────────────────────┐
│                  PowerDNS Recursor                       │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │          Application Layer                         │ │
│  │  (rec-main.cc, pdns_recursor.cc)                  │ │
│  │  - Query handling                                  │ │
│  │  - Configuration                                   │ │
│  │  - Statistics                                      │ │
│  └────────────┬───────────────────────────────────────┘ │
│               │                                          │
│  ┌────────────▼───────────────────────────────────────┐ │
│  │          Core DNS Logic Layer                      │ │
│  │  (syncres.cc, recursor_cache.cc, validate.cc)    │ │
│  │  - Recursive resolution                            │ │
│  │  - Caching                                         │ │
│  │  - DNSSEC validation                              │ │
│  │  ✅ PLATFORM-INDEPENDENT                          │ │
│  └────────────┬───────────────────────────────────────┘ │
│               │                                          │
│  ┌────────────▼───────────────────────────────────────┐ │
│  │       Platform Abstraction Layer                   │ │
│  │  (NEW: Platform interface definitions)             │ │
│  │  - FDMultiplexer (I/O events)                     │ │
│  │  - NetworkIO (sockets)                             │ │
│  │  - ProcessManager (threads/processes)              │ │
│  └──┬────────────────────────────────────────────┬────┘ │
│     │                                            │      │
│  ┌──▼──────────────────┐          ┌─────────────▼────┐ │
│  │  Linux Platform     │          │ Windows Platform │ │
│  │  - epollmplexer.cc  │          │ - libeventmplexer│ │
│  │  - Unix sockets     │          │ - Winsock2       │ │
│  │  - fork/signals     │          │ - Windows Service│ │
│  └─────────────────────┘          └──────────────────┘ │
└──────────────────────────────────────────────────────────┘
```

### 2.2 Component Architecture

**Strategy**: Maintain original PowerDNS flat file structure + conditional compilation

```
pdns_recursor_windows/    (Same structure as original pdns-recursor/)
├── rec-main.cc           ✅ Add #ifdef _WIN32 for Windows threading
├── syncres.cc            ✅ Platform-independent (no changes)
├── dnsparser.cc          ✅ Platform-independent (no changes)
├── dnswriter.cc          ✅ Platform-independent (no changes)
├── recursor_cache.cc     ✅ Platform-independent (no changes)
├── mplexer.hh            ✅ Interface (no changes)
├── epollmplexer.cc       #ifdef __linux__ (existing, keep as-is)
├── kqueuemplexer.cc      #ifdef __FreeBSD__ (existing, keep as-is)
├── pollmplexer.cc        #ifdef (existing, keep as-is)
├── portsmplexer.cc       #ifdef (existing, keep as-is)
├── devpollmplexer.cc     #ifdef (existing, keep as-is)
├── libeventmplexer.cc    #ifdef _WIN32 (NEW - Windows I/O)
├── capabilities.cc       #ifdef __linux__ (existing, keep as-is)
├── rec_channel.cc        ✅ Add #ifdef _WIN32 for Windows IPC
├── ws-recursor.cc        ✅ Mostly platform-independent
├── config.h              Generated by CMake (Windows-specific)
├── CMakeLists.txt        NEW (Windows build system)
├── Makefile.am           Keep as-is (Linux/autotools)
├── configure.ac          Keep as-is (Linux/autotools)
└── (all other 200+ files) Copy as-is from original

Key Principles:
1. Same file names, same flat structure
2. Use #ifdef _WIN32 / __linux__ within files
3. Linux builds remain untouched (autotools still works)
4. Windows builds use CMake (new)
5. Platform-independent code shared by both
```

---

## 3. Platform Abstraction Design

### 3.1 I/O Multiplexer Abstraction

**Current State (Linux-only)**:
```cpp
// rec-main.cc
std::unique_ptr<FDMultiplexer> getMultiplexer() {
    return std::make_unique<EpollMultiplexer>();
}
```

**Target State (Cross-platform)**:
```cpp
// rec-main.cc
std::unique_ptr<FDMultiplexer> getMultiplexer() {
#ifdef _WIN32
    return std::make_unique<LibeventMultiplexer>();
#elif defined(__linux__)
    return std::make_unique<EpollMultiplexer>();
#elif defined(__APPLE__) || defined(__FreeBSD__)
    return std::make_unique<KqueueMultiplexer>();
#else
    return std::make_unique<PollMultiplexer>();
#endif
}
```

**Interface** (already exists - `mplexer.hh`):
```cpp
class FDMultiplexer {
public:
    virtual void addReadFD(int fd, callback_t cb, ...);
    virtual void addWriteFD(int fd, callback_t cb, ...);
    virtual void removeReadFD(int fd);
    virtual void removeWriteFD(int fd);
    virtual int run(struct timeval* tv, int timeout);
    virtual ~FDMultiplexer();
};
```

**Windows Implementation Options**:

| Option | Pros | Cons | Recommendation |
|--------|------|------|----------------|
| **libevent** | ✅ Proven, easy | ⚠️ External dep | **Phase 1 (POC)** |
| **WSAWaitForMultipleEvents** | ✅ No deps, like Unbound | ⚠️ 64 socket limit | **Phase 2** |
| **IOCP** | ✅ Best performance | ❌ Complex rewrite | **Phase 3 (optional)** |

---

### 3.2 Socket Abstraction

**Current Challenges**:
```cpp
// Unix code
#include <sys/socket.h>
#include <netinet/in.h>
int fd = socket(AF_INET, SOCK_DGRAM, 0);
close(fd);

// Windows requires
#include <winsock2.h>
SOCKET fd = socket(AF_INET, SOCK_DGRAM, 0);
closesocket(fd);
```

**Solution: Compatibility Layer**:
```cpp
// platform/socket_compat.hh
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    typedef SOCKET socket_t;
    #define CLOSE_SOCKET closesocket
    #define SOCKET_ERROR_CODE WSAGetLastError()
    inline void initSockets() {
        WSADATA wsaData;
        WSAStartup(MAKEWORD(2,2), &wsaData);
    }
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    typedef int socket_t;
    #define CLOSE_SOCKET close
    #define SOCKET_ERROR_CODE errno
    inline void initSockets() {}
#endif
```

**Usage in Code**:
```cpp
// In source files
#include "platform/socket_compat.hh"

socket_t fd = socket(AF_INET, SOCK_DGRAM, 0);
if (fd == INVALID_SOCKET) {
    error("Socket creation failed: " + SOCKET_ERROR_CODE);
}
CLOSE_SOCKET(fd);
```

---

### 3.3 Threading & Process Management

**Current State (fork-based)**:
```cpp
// rec-main.cc
for (int i=0; i < num_processes; i++) {
    if (fork() == 0) {  // Child process
        worker_main();
        exit(0);
    }
}
```

**Problem**: Windows doesn't have `fork()`

**Solution**: Thread-based on Windows
```cpp
// rec-main.cc
#ifdef _WIN32
// Windows: Use threads (PowerDNS already has std::thread support)
std::vector<std::thread> workers;
for (int i=0; i < num_threads; i++) {
    workers.emplace_back(worker_main, i);
}
for (auto& t : workers) {
    t.join();
}
#else
// Linux: Keep existing fork() code
for (int i=0; i < num_processes; i++) {
    if (fork() == 0) {
        worker_main();
        exit(0);
    }
}
#endif
```

**Trade-offs**:
- ✅ Simpler on Windows (shared memory)
- ⚠️ Different isolation model
- ✅ PowerDNS already uses threads internally
- ✅ Unbound uses this approach

---

### 3.4 Configuration & Control

**rec_control Communication**:

**Current (Unix sockets)**:
```cpp
// rec_channel.cc
int sock = socket(AF_UNIX, SOCK_STREAM, 0);
connect(sock, "/var/run/pdns_recursor.sock");
```

**Windows Alternative 1: TCP localhost**:
```cpp
#ifdef _WIN32
    // Use TCP on localhost
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    connect(sock, "127.0.0.1:8954");
#else
    // Unix socket
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    connect(sock, "/var/run/pdns_recursor.sock");
#endif
```

**Windows Alternative 2: Named Pipes**:
```cpp
#ifdef _WIN32
    HANDLE pipe = CreateFile(
        "\\\\.\\pipe\\pdns_recursor",
        GENERIC_READ | GENERIC_WRITE,
        0, NULL, OPEN_EXISTING, 0, NULL
    );
#endif
```

**Recommendation**: TCP localhost (simpler, works everywhere)

---

## 4. Data Flow Architecture

### 4.1 Query Processing Flow

```
Client Query (UDP/TCP)
    ↓
┌───▼────────────────────────┐
│  Socket Layer              │
│  (platform/network_io)     │
│  - Winsock2 (Windows)      │
│  - Unix sockets (Linux)    │
└───┬────────────────────────┘
    ↓
┌───▼────────────────────────┐
│  I/O Multiplexer           │
│  (platform/multiplexer)    │
│  - libevent (Windows)      │
│  - epoll (Linux)           │
└───┬────────────────────────┘
    ↓
┌───▼────────────────────────┐
│  Query Handler             │
│  (pdns_recursor.cc)        │
│  ✅ Platform-independent   │
└───┬────────────────────────┘
    ↓
┌───▼────────────────────────┐
│  Recursive Resolver        │
│  (syncres.cc)              │
│  ✅ Platform-independent   │
│  - Check cache             │
│  - Query root/TLD/auth     │
│  - DNSSEC validation       │
└───┬────────────────────────┘
    ↓
┌───▼────────────────────────┐
│  Cache Layer               │
│  (recursor_cache.cc)       │
│  ✅ Platform-independent   │
└───┬────────────────────────┘
    ↓
    Response to Client
```

---

## 5. Build System Architecture

### 5.1 Cross-Platform Build

**Dual Build System Strategy**:
```
Linux Users:
    ./configure && make        (autotools - unchanged)

Windows Users:
    cmake .. && cmake --build .   (CMake - new)
    
    Two Compiler Options:
    ├── MSVC (Visual Studio)   ← RECOMMENDED for PowerShell/cmd
    └── MinGW (GCC)            ← Alternative (requires MSYS2)

Both Systems:
    Same source files!
    Different platform code compiled based on #ifdef
```

### 5.2 Windows Compiler Support

#### 5.2.1 MSVC (Visual Studio) - Recommended

**Advantages**:
- ✅ Native Windows toolchain
- ✅ Build from PowerShell/cmd (no MSYS2 terminal)
- ✅ Best Windows performance
- ✅ Better debugging (Visual Studio IDE)
- ✅ Professional Windows development
- ✅ Better optimizer for Windows

**Build Commands**:
```powershell
# PowerShell (native Windows)
cd pdns_recursor_windows
mkdir build && cd build
cmake .. -G "Visual Studio 17 2022" -DCMAKE_TOOLCHAIN_FILE=../vcpkg/scripts/buildsystems/vcpkg.cmake
cmake --build . --config Release
```

**Compiler-Specific Code**:
```cpp
#ifdef _MSC_VER
    #pragma comment(lib, "ws2_32.lib")
    #pragma comment(lib, "iphlpapi.lib")
    #define PORTABLE_SNPRINTF _snprintf
    #define PORTABLE_SLEEP(s) Sleep((s) * 1000)
#endif
```

#### 5.2.2 MinGW (GCC) - Alternative

**Advantages**:
- ✅ GCC compiler (closer to Linux)
- ✅ Easier code porting (fewer compiler errors)
- ✅ POSIX compatibility layer
- ✅ Proven by Unbound

**Build Commands**:
```bash
# MSYS2 terminal (not PowerShell!)
cd /c/pdns-recursor-5.3.0.2.relrec53x.g594400838/pdns_recursor_windows
mkdir build && cd build
cmake .. -G "MinGW Makefiles"
make -j$(nproc)
```

**Compiler-Specific Code**:
```cpp
#ifdef __MINGW32__
    // MinGW provides some POSIX stubs
    #define PORTABLE_SNPRINTF snprintf
    #define PORTABLE_SLEEP(s) sleep(s)
#endif
```

### 5.3 CMake Structure (Dual Compiler Support)

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.15)
project(pdns_recursor CXX)

# Compiler detection
if(MSVC)
    message(STATUS "Building with MSVC (Visual Studio)")
    add_compile_options(/W4 /std:c++17 /EHsc)
    add_definitions(-D_WIN32_WINNT=0x0601)  # Windows 7+
elseif(MINGW)
    message(STATUS "Building with MinGW (GCC)")
    add_compile_options(-Wall -Wextra -std=c++17)
endif()

# Platform-independent sources (FLAT STRUCTURE - root level)
set(CORE_SOURCES
    syncres.cc
    dnsparser.cc
    dnswriter.cc
    dnsname.cc
    recursor_cache.cc
    negcache.cc
    qtype.cc
    # ... all other core .cc files
)

# Platform-specific multiplexers (all at root level!)
if(WIN32)
    # Windows: Use libevent multiplexer
    list(APPEND PLATFORM_SOURCES
        libeventmplexer.cc    # NEW file (same level as epollmplexer.cc)
    )
    
    # Windows-specific libraries
    list(APPEND PLATFORM_LIBS ws2_32 iphlpapi)
    
    # MSVC needs explicit pragma comments alternative
    if(MSVC)
        list(APPEND PLATFORM_LIBS Ws2_32.lib iphlpapi.lib)
    endif()
    
    # Find libevent
    find_package(Libevent REQUIRED)
    list(APPEND PLATFORM_LIBS ${LIBEVENT_LIBRARIES})
    
elseif(UNIX)
    # Linux: Use existing epoll multiplexer
    list(APPEND PLATFORM_SOURCES
        epollmplexer.cc       # Existing file (unchanged)
    )
    if(LINUX)
        list(APPEND PLATFORM_LIBS systemd)
        list(APPEND PLATFORM_SOURCES capabilities.cc)
    endif()
endif()

add_executable(pdns_recursor 
    ${CORE_SOURCES}
    ${PLATFORM_SOURCES}
)

target_link_libraries(pdns_recursor
    ${PLATFORM_LIBS}
    Boost::context
    Boost::system
    OpenSSL::SSL
    OpenSSL::Crypto
)

# Compiler-specific post-build settings
if(MSVC)
    # Copy DLLs to output directory
    add_custom_command(TARGET pdns_recursor POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
        $<TARGET_FILE:OpenSSL::SSL> $<TARGET_FILE_DIR:pdns_recursor>
    )
endif()
```

### 5.4 Dependency Management

#### vcpkg (MSVC Recommended)
```powershell
# Install vcpkg
git clone https://github.com/microsoft/vcpkg
.\vcpkg\bootstrap-vcpkg.bat
.\vcpkg\vcpkg install boost-context boost-system openssl libevent --triplet x64-windows
```

#### pacman (MinGW)
```bash
# In MSYS2 terminal
pacman -S mingw-w64-x86_64-boost
pacman -S mingw-w64-x86_64-openssl
pacman -S mingw-w64-x86_64-libevent
```

### 5.5 Cross-Compiler Compatibility

**Code must work with BOTH compilers**:
```cpp
// platform/compiler_compat.hh
#ifdef _WIN32
  #include <winsock2.h>
  #include <ws2tcpip.h>
  
  // MSVC-specific
  #ifdef _MSC_VER
    #pragma comment(lib, "ws2_32.lib")
    #define PORTABLE_SNPRINTF _snprintf
    #define PORTABLE_SLEEP(s) Sleep((s) * 1000)
  #endif
  
  // MinGW-specific
  #ifdef __MINGW32__
    #define PORTABLE_SNPRINTF snprintf
    #define PORTABLE_SLEEP(s) sleep(s)
  #endif
  
  // Common Windows
  typedef SOCKET socket_t;
  #define CLOSE_SOCKET closesocket
  #define SOCKET_ERROR_CODE WSAGetLastError()
  
#else
  // Linux
  #include <sys/socket.h>
  #include <unistd.h>
  typedef int socket_t;
  #define CLOSE_SOCKET close
  #define SOCKET_ERROR_CODE errno
  #define PORTABLE_SNPRINTF snprintf
  #define PORTABLE_SLEEP(s) sleep(s)
#endif
```

---

## 6. Security Architecture

### 6.1 Privilege Model

**Linux**:
```
Start as root → Bind to port 53 → Drop to 'pdns' user
Uses: setuid(), capabilities
```

**Windows**:
```
Option 1: Run as LocalService (built-in low-privilege account)
Option 2: Run as specific user (configured via Service Control Manager)
```

### 6.2 Input Validation

**Cross-Platform Strategy**:
- All input validation in core (platform-independent)
- No platform-specific validation needed
- Same security guarantees on all platforms

---

## 7. Performance Considerations

### 7.1 I/O Performance

**Linux (epoll)**:
```
Optimized for high throughput
- O(1) event notification
- Level-triggered or edge-triggered
- Handles 10,000+ events/sec
```

**Windows (libevent/WSAPoll)**:
```
Good performance
- O(n) event notification (WSAPoll)
- Level-triggered
- Handles 8,000+ events/sec (target)
- Future: IOCP for O(1) if needed
```

### 7.2 Threading Model

**Linux**: Multi-process (current)
- Better isolation
- Separate memory spaces
- fork() overhead minimal on Linux

**Windows**: Multi-threaded
- Shared memory (faster IPC)
- No fork() overhead
- Requires thread-safe code

**Mitigation**: PowerDNS already thread-safe (uses MTasker, shared caches)

---

## 8. Deployment Architecture

### 8.1 Linux Deployment (Unchanged)

```
Package: .deb or .rpm
Service: systemd
Config: /etc/powerdns/recursor.conf
Logs: journalctl
Control: systemctl, rec_control
```

### 8.2 Windows Deployment (New)

```
Package: .msi installer
Service: Windows Service (Services.msc)
Config: C:\Program Files\PowerDNS\recursor.conf
Logs: Windows Event Log
Control: sc.exe, net.exe, rec_control.exe
```

---

## 9. Monitoring & Observability

### 9.1 Metrics Collection

**Platform-Independent**:
- Query counters
- Cache hit/miss rates
- Latency percentiles
- DNSSEC validation stats

**Platform-Specific**:
```cpp
#ifdef _WIN32
    // Windows Performance Counters
    PDH_HQUERY query;
    PdhOpenQuery(NULL, 0, &query);
#else
    // Read from /proc
    std::ifstream("/proc/self/stat");
#endif
```

### 9.2 Logging

**Abstraction**:
```cpp
// platform/logging.hh
class PlatformLogger {
public:
    virtual void log(Level, const std::string& msg) = 0;
};

#ifdef _WIN32
class WindowsEventLogger : public PlatformLogger {
    void log(Level, const std::string& msg) override {
        // Write to Windows Event Log
        ReportEvent(...);
    }
};
#else
class SyslogLogger : public PlatformLogger {
    void log(Level, const std::string& msg) override {
        syslog(LOG_INFO, "%s", msg.c_str());
    }
};
#endif
```

---

## 10. Testing Strategy

### 10.1 Test Pyramid

```
       /\
      /  \     E2E Tests (10%)
     /────\    - Full system tests
    /      \   - Platform-specific
   /────────\  Integration Tests (30%)
  /          \ - Component integration
 /────────────\ - Cross-platform
/              \ Unit Tests (60%)
──────────────── - Core logic tests
                 - Platform-agnostic
```

### 10.2 Platform-Specific Testing

**Windows Tests**:
- Windows Service lifecycle
- Windows Event Log
- Winsock functionality
- Performance benchmarks

**Linux Tests** (regression):
- All existing tests must pass
- Performance must not degrade
- systemd integration

---

## 11. Migration Path

### 11.1 Code Migration Strategy

**Phase 1: Additive Changes**
```cpp
// Step 1: Add Windows code alongside Linux code
#ifdef _WIN32
    // New Windows code
#else
    // Existing Linux code (untouched)
#endif
```

**Phase 2: Extract Common Code**
```cpp
// Step 2: Extract to platform-independent functions
void commonLogic() {
    // Shared code
}

#ifdef _WIN32
    void platformSpecific() { /* Windows */ }
#else
    void platformSpecific() { /* Linux */ }
#endif
```

### 11.2 File Organization Migration

```
Current:
    pdns-recursor/syncres.cc (Linux-specific parts mixed in)

Target:
    pdns-recursor/core/syncres.cc (platform-independent)
    pdns-recursor/linux/linux_specific.cc (#ifdef __linux__)
    pdns-recursor/windows/windows_specific.cc (#ifdef _WIN32)
```

**Approach**: Gradual refactoring, don't break existing code

---

## 12. Risk Mitigation

### 12.1 Technical Risks

**Risk**: Performance regression on Linux
**Mitigation**:
- #ifdef keeps Linux code unchanged
- Performance benchmarks in CI
- Platform-specific optimizations allowed

**Risk**: API incompatibilities
**Mitigation**:
- Thin abstraction layer
- Reference Unbound's solutions
- Extensive testing

### 12.2 Operational Risks

**Risk**: Increased maintenance burden
**Mitigation**:
- Clear platform separation
- Good documentation
- Automated testing

---

## 13. Architectural Decisions

### 13.1 Key Decisions

**AD-001: Use libevent for Windows I/O (POC)**
- **Decision**: Use libevent instead of direct IOCP
- **Rationale**: Faster development, proven solution
- **Consequences**: External dependency, good-enough performance
- **Status**: Approved for Phase 1

**AD-002: Thread-based on Windows, fork-based on Linux**
- **Decision**: Different concurrency models per platform
- **Rationale**: Play to each platform's strengths
- **Consequences**: Need thread-safe code (already is)
- **Status**: Approved

**AD-003: Single source tree with #ifdef**
- **Decision**: One codebase, conditional compilation
- **Rationale**: Easier maintenance than separate branches
- **Consequences**: More #ifdef, but manageable
- **Status**: Approved

**AD-004: TCP localhost for rec_control on Windows**
- **Decision**: Use TCP instead of Unix sockets for IPC
- **Rationale**: Simpler than Named Pipes, works everywhere
- **Consequences**: Network stack involvement, still localhost only
- **Status**: Approved

---

## 14. Open Questions

1. **IOCP vs libevent**: Should we invest in IOCP for better Windows performance?
   - **Answer**: Phase 1 uses libevent, evaluate later

2. **MSI installer**: Who builds the Windows installer?
   - **Answer**: Use WiX Toolset, automated in CI

3. **Windows versions**: Support Windows 7 or only 10+?
   - **Answer**: Windows 10+ only (simpler, modern APIs)

---

## 15. Next Steps

1. ✅ Review and approve this architecture
2. → Create detailed implementation plan (phases)
3. → Break down into sprints and stories
4. → Begin Phase 1 (POC) implementation

---

**Document Status**: Ready for Implementation Planning  
**Next Document**: Implementation Plan & Sprint Breakdown

